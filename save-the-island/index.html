<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>우리 섬을 지켜라! - DEFEND THE ISLAND</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Oxanium:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --sky-top: #1e3c72;
        --sky-bottom: #2a5298;
        --sea: #1c4b7a;
        --sea-light: #2f7bc3;
        --accent: #ffcf4b;
        --danger: #ff5f5f;
        --island-enemy: #5d4037;
        --island-player: #2e7d32;
        --glass: rgba(15, 23, 42, 0.8);
      }

      * {
        box-sizing: border-box;
        user-select: none;
      }

      body {
        margin: 0;
        font-family: "Oxanium", "Segoe UI", sans-serif;
        background: #0f172a;
        overflow: hidden;
        color: white;
      }

      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        cursor: crosshair;
      }

      .hud {
        position: fixed;
        top: 20px;
        left: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        pointer-events: none;
        z-index: 10;
      }

      .panel {
        background: var(--glass);
        backdrop-filter: blur(8px);
        padding: 18px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        pointer-events: auto;
        width: 240px;
      }

      h1 {
        margin: 0 0 15px;
        font-family: "Black Han Sans", sans-serif;
        font-size: 24px;
        color: var(--accent);
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      }

      .stat-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        font-weight: 600;
      }

      .stat-label {
        color: #94a3b8;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .stat-value {
        font-size: 18px;
      }

      .hp-bar-container {
        width: 100%;
        height: 8px;
        background: rgba(255,255,255,0.1);
        border-radius: 4px;
        margin: 10px 0 20px;
        overflow: hidden;
      }

      #hp-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--danger), #ff8a8a);
        width: 100%;
        transition: width 0.3s ease-out;
      }

      .money-text {
        color: var(--accent);
        font-size: 24px;
        font-weight: 700;
      }

      .btn {
        width: 100%;
        padding: 12px;
        border: none;
        border-radius: 12px;
        background: linear-gradient(135deg, #fbbf24, #f59e0b);
        color: #451a03;
        font-weight: 800;
        font-family: inherit;
        cursor: pointer;
        transition: transform 0.1s, filter 0.2s;
        margin-top: 10px;
      }

      .btn:hover:not(:disabled) {
        filter: brightness(1.1);
        transform: translateY(-2px);
      }

      .btn:active:not(:disabled) {
        transform: translateY(0);
      }

      .btn:disabled {
        background: #475569;
        color: #94a3b8;
        cursor: not-allowed;
      }

      .controls-tip {
        font-size: 11px;
        color: #64748b;
        margin-top: 15px;
        line-height: 1.5;
        text-align: center;
      }

      .item-badge {
        display: inline-block;
        padding: 4px 8px;
        background: #334155;
        border-radius: 6px;
        font-size: 12px;
        color: #e2e8f0;
        margin-top: 10px;
      }

      .item-ready {
        background: #059669;
        color: white;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.7; }
        100% { opacity: 1; }
      }

      .game-over {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.9);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        backdrop-filter: blur(10px);
      }

      .game-over.show {
        display: flex;
      }

      .game-over h2 {
        font-family: "Black Han Sans", sans-serif;
        font-size: 64px;
        margin: 0;
        color: var(--danger);
      }

      .game-over p {
        font-size: 20px;
        margin: 20px 0;
        color: #94a3b8;
      }

      #restart-btn {
        max-width: 200px;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="panel">
        <h1>우리 섬을 지켜라!</h1>
        <div class="stat-row">
          <span class="stat-label">Main Gun</span>
          <span class="stat-value">Lv.<span id="gun-level">1</span></span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Currency</span>
          <span class="money-text" id="money">$0</span>
        </div>
        <button class="btn" id="upgrade-btn">Upgrade Gun ($20)</button>
        <div id="item-status" class="item-badge">No Special Item</div>
        <div class="controls-tip">
          L-Click: Gun • R-Click: Cannon<br />
          [X]: Special Weapon
        </div>
      </div>
    </div>

    <div class="game-over" id="game-over">
      <h2>MISSION FAILED</h2>
      <p>The island has fallen.</p>
      <button class="btn" id="restart-btn">Try Again (R)</button>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      // Audio System (Procedural)
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const Sfx = {
        init() {
          if (audioCtx.state === "suspended") audioCtx.resume();
        },
        play(type) {
          this.init();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);

          const now = audioCtx.currentTime;

          switch(type) {
            case "shoot":
              osc.type = "square";
              osc.frequency.setValueAtTime(800, now);
              osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
              gain.gain.setValueAtTime(0.1, now);
              gain.gain.linearRampToValueAtTime(0, now + 0.1);
              osc.start();
              osc.stop(now + 0.1);
              break;
            case "explosion":
              osc.type = "sawtooth";
              osc.frequency.setValueAtTime(150, now);
              osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);
              gain.gain.setValueAtTime(0.3, now);
              gain.gain.linearRampToValueAtTime(0, now + 0.3);
              osc.start();
              osc.stop(now + 0.3);
              break;
            case "heavy":
              osc.type = "triangle";
              osc.frequency.setValueAtTime(200, now);
              osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
              gain.gain.setValueAtTime(0.5, now);
              gain.gain.linearRampToValueAtTime(0, now + 0.5);
              osc.start();
              osc.stop(now + 0.5);
              break;
            case "coin":
              osc.type = "sine";
              osc.frequency.setValueAtTime(900, now);
              osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
              gain.gain.setValueAtTime(0.1, now);
              gain.gain.linearRampToValueAtTime(0, now + 0.2);
              osc.start();
              osc.stop(now + 0.2);
              break;
            case "damage":
              osc.type = "sawtooth";
              osc.frequency.setValueAtTime(60, now);
              gain.gain.setValueAtTime(0.4, now);
              gain.gain.linearRampToValueAtTime(0, now + 0.4);
              osc.start();
              osc.stop(now + 0.4);
              break;
            case "powerup":
              osc.type = "sine";
              osc.frequency.setValueAtTime(400, now);
              osc.frequency.exponentialRampToValueAtTime(1500, now + 0.5);
              gain.gain.setValueAtTime(0.2, now);
              gain.gain.linearRampToValueAtTime(0, now + 0.5);
              osc.start();
              osc.stop(now + 0.5);
              break;
          }
        }
      };

      // UI elements
      const ui = {
        money: document.getElementById("money"),
        gunLevel: document.getElementById("gun-level"),
        upgradeBtn: document.getElementById("upgrade-btn"),
        itemStatus: document.getElementById("item-status"),
        gameOver: document.getElementById("game-over"),
        restartBtn: document.getElementById("restart-btn")
      };

      let width, height;
      const seaRatio = 0.12;
      const islandWidthRatio = 0.22;

      const state = {
        money: 0,
        baseHp: 100,
        maxHp: 100,
        gunLevel: 1,
        gunCooldown: 0,
        cannonCooldown: 0,
        itemReady: false,
        launcherAlive: true,
        launcherHp: 6,
        launcherMaxHp: 6,
        launcherCooldown: 0,
        aim: { x: 0, y: 0 },
        lastTime: 0,
        gameOver: false,
        shake: 0,
        frame: 0
      };

      const projectiles = [];
      const enemies = [];
      const gifts = [];
      const enemyMissiles = [];
      const popups = [];
      const particles = [];
      const clouds = [];

      // Initialize clouds
      for(let i=0; i<6; i++) {
        clouds.push({
          x: Math.random() * 2000,
          y: Math.random() * 300,
          speed: 0.2 + Math.random() * 0.5,
          scale: 0.8 + Math.random() * 1.2
        });
      }

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * window.devicePixelRatio;
        canvas.height = height * window.devicePixelRatio;
        ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
      }

      window.addEventListener("resize", resize);
      resize();

      const getSeaY = () => height * (1 - seaRatio);
      const getIslandWidth = () => width * islandWidthRatio;
      const getTurretPos = () => ({ x: width - getIslandWidth() * 0.5, y: getSeaY() - 65 });
      const getLauncherPos = () => ({ x: getIslandWidth() * 0.5, y: getSeaY() - 75 });

      function createExplosion(x, y, color, count = 12) {
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 4 + 2;
          particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            decay: 0.02 + Math.random() * 0.03,
            size: Math.random() * 4 + 2,
            color
          });
        }
      }

      function addMoney(amount, x, y) {
        state.money += amount;
        Sfx.play("coin");
        popups.push({
          x, y, text: `+$${amount}`, life: 1, color: "#fbbf24", size: 18
        });
        updateHud();
      }

      function updateHud() {
        ui.money.textContent = `$${state.money}`;
        ui.gunLevel.textContent = state.gunLevel;
        
        const cost = state.gunLevel * 25;
        ui.upgradeBtn.textContent = state.gunLevel >= 8 ? "MAX LEVEL" : `Upgrade Gun ($${cost})`;
        ui.upgradeBtn.disabled = state.money < cost || state.gunLevel >= 8;

        if (state.itemReady) {
          ui.itemStatus.textContent = "MEGA BLAST READY [X]";
          ui.itemStatus.className = "item-badge item-ready";
        } else {
          ui.itemStatus.textContent = "No Special Item";
          ui.itemStatus.className = "item-badge";
        }
      }

      ui.upgradeBtn.addEventListener("click", () => {
        const cost = state.gunLevel * 25;
        if (state.money >= cost && state.gunLevel < 8) {
          state.money -= cost;
          state.gunLevel++;
          updateHud();
          createExplosion(width - 100, 100, "#fbbf24", 20);
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        state.aim.x = e.clientX;
        state.aim.y = e.clientY;
      });

      canvas.addEventListener("mousedown", (e) => {
        if (state.gameOver) return;
        if (e.button === 2) {
          // Cannon is now more of a secondary/item-like heavy shot
          fireCannon();
        } else {
          fireGun();
        }
      });

      canvas.addEventListener("contextmenu", (e) => e.preventDefault());

      window.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "x" && state.itemReady && !state.gameOver) fireSuperShot();
        if (e.key.toLowerCase() === "r" && state.gameOver) restart();
      });
      ui.restartBtn.addEventListener("click", restart);

      function fireGun() {
        if (state.gunCooldown > 0) return;
        Sfx.play("shoot");
        
        const tx = state.aim.x;
        const ty = state.aim.y;
        
        // Instant "Pop" at target
        createExplosion(tx, ty, "#fff", 5);
        createExplosion(tx, ty, "#fbbf24", 3);
        
        // Flash at muzzle
        const origin = getTurretPos();
        createExplosion(origin.x, origin.y, "#fff", 2);

        // Check hits at target location
        let hitSomething = false;
        const hitRadius = 15;

        // Hit Enemy
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (Math.hypot(tx - e.x, ty - e.y) < e.size + hitRadius) {
            e.hp -= (2 + state.gunLevel);
            hitSomething = true;
            if (e.hp <= 0) {
              Sfx.play("explosion");
              createExplosion(e.x, e.y, "#f87171", 20);
              addMoney(e.reward, e.x, e.y);
              enemies.splice(j, 1);
            }
          }
        }

        // Hit Missile
        if (!hitSomething) {
          for (let j = enemyMissiles.length - 1; j >= 0; j--) {
            const m = enemyMissiles[j];
            if (Math.hypot(tx - m.x, ty - m.y) < m.radius + hitRadius) {
              createExplosion(m.x, m.y, "#ffaa00", 10);
              addMoney(1, m.x, m.y);
              enemyMissiles.splice(j, 1);
              hitSomething = true;
            }
          }
        }

        // Hit Launcher
        if (!hitSomething && state.launcherAlive) {
          const l = getLauncherPos();
          if (Math.hypot(tx - l.x, ty - l.y) < 30 + hitRadius) {
            state.launcherHp -= (2 + state.gunLevel);
            if (state.launcherHp <= 0) {
              state.launcherAlive = false;
              state.launcherCooldown = 10000;
              createExplosion(l.x, l.y, "#ef4444", 40);
              addMoney(5, l.x, l.y);
              updateHud();
            }
          }
        }

        // Hit Gift
        if (!hitSomething) {
          for (let j = gifts.length - 1; j >= 0; j--) {
            const g = gifts[j];
            if (Math.hypot(tx - g.x, ty - g.y) < g.size + hitRadius) {
              createExplosion(g.x, g.y, "#fbbf24", 15);
              if (Math.random() > 0.6) {
                state.itemReady = true;
                Sfx.play("powerup");
                popups.push({ x: g.x, y: g.y, text: "SPECIAL WEAPON!", life: 1.5, color: "#4ade80", size: 20 });
              } else {
                addMoney(10, g.x, g.y);
              }
              gifts.splice(j, 1);
              updateHud();
            }
          }
        }

        state.gunCooldown = Math.max(120 - state.gunLevel * 12, 40);
        state.shake = 1.5;
      }

      function fireCannon() {
        if (state.cannonCooldown > 0) return;
        Sfx.play("heavy");
        const origin = getTurretPos();
        const angle = Math.atan2(state.aim.y - origin.y, state.aim.x - origin.x);
        projectiles.push({
          x: origin.x, y: origin.y,
          vx: Math.cos(angle) * 9,
          vy: Math.sin(angle) * 9,
          radius: 8, damage: 15,
          color: "#fbbf24", type: "cannon", splash: 60
        });
        state.cannonCooldown = 400;
        state.shake = 8;
      }

      function fireSuperShot() {
        state.itemReady = false;
        Sfx.play("heavy");
        const origin = getTurretPos();
        const angle = Math.atan2(state.aim.y - origin.y, state.aim.x - origin.x);
        projectiles.push({
          x: origin.x, y: origin.y,
          vx: Math.cos(angle) * 7,
          vy: Math.sin(angle) * 7,
          radius: 15, damage: 40,
          color: "#ef4444", type: "super", splash: 120
        });
        state.shake = 20;
        updateHud();
      }


      function spawnEnemy() {
        const roll = Math.random();
        const seaY = getSeaY();
        const iw = getIslandWidth();
        
        let type = "ship", x = -60, y = seaY - 25, hp = 12, speed = 1.0, targetY = y, takingOff = false;
        
        if (roll > 0.6 && roll <= 0.85) { 
          type = "heli"; 
          y = 100 + Math.random() * 200; 
          hp = 8; 
          speed = 1.6; 
          targetY = y;
        } else if (roll > 0.85) { 
          type = "jet"; 
          x = iw * 0.3; // Start on enemy island
          y = seaY - 85; // On the ground
          hp = 6; 
          speed = 3.5; 
          targetY = 50 + Math.random() * 120; // Flight altitude
          takingOff = true;
        }
        
        enemies.push({ 
          x, y, type, hp, speed, size: 25, reward: 5, targetY, takingOff,
          fireCooldown: 1000 + Math.random() * 2000 
        });
      }

      function spawnGift() {
        gifts.push({
          x: getIslandWidth() + Math.random() * (width - getIslandWidth() * 2),
          y: -30, speed: 1.5 + Math.random(), size: 20
        });
      }

      function spawnEnemyMissile() {
        if (!state.launcherAlive) return;
        const start = getLauncherPos();
        const target = getTurretPos();
        const angle = Math.atan2(target.y - start.y, target.x - start.x);
        enemyMissiles.push({
          x: start.x, y: start.y,
          vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3,
          radius: 5
        });
      }

      const timers = { enemy: 0, gift: 0, missile: 0 };

      function update(delta) {
        if (state.gameOver) return;
        state.frame++;
        state.gunCooldown = Math.max(0, state.gunCooldown - delta);
        state.cannonCooldown = Math.max(0, state.cannonCooldown - delta);
        state.shake *= 0.9;

        if (!state.launcherAlive) {
          state.launcherCooldown -= delta;
          if (state.launcherCooldown <= 0) {
            state.launcherAlive = true;
            state.launcherHp = state.launcherMaxHp;
            updateHud();
          }
        }

        timers.enemy += delta;
        timers.gift += delta;
        timers.missile += delta;

        if (timers.enemy > 2000) { spawnEnemy(); timers.enemy = 0; }
        if (timers.gift > 10000) { spawnGift(); timers.gift = 0; }
        if (timers.missile > 4000) { spawnEnemyMissile(); timers.missile = 0; }

        // Clouds
        clouds.forEach(c => {
          c.x -= c.speed;
          if (c.x < -200) c.x = width + 200;
        });

        // Projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const p = projectiles[i];
          p.x += p.vx; p.y += p.vy;
          if (p.x < 0 || p.x > width || p.y < 0 || p.y > height) projectiles.splice(i, 1);
        }

        // Enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          e.x += e.speed;
          
          if (e.takingOff) {
            e.y -= 2;
            if (e.y <= e.targetY) { e.y = e.targetY; e.takingOff = false; }
          }

          // Drop bombs (Heli and Jet)
          if (e.type !== "ship" && !e.takingOff) {
            e.fireCooldown -= delta;
            
            const target = getTurretPos();
            const gravity = 0.05;
            const dy = target.y - e.y;
            
            // Calculate how far a bomb will travel horizontally if dropped now with vy=0
            // t = sqrt(2dy/g)
            const fallTime = Math.sqrt((2 * dy) / gravity);
            const horizontalDist = (e.speed + 1.5) * fallTime;
            const currentDistToTarget = target.x - e.x;

            // Drop if we are at the right distance for a natural forward drop
            if (e.fireCooldown <= 0 && currentDistToTarget <= horizontalDist + 50 && currentDistToTarget >= horizontalDist - 50) {
              enemyMissiles.push({
                x: e.x, y: e.y,
                vx: e.speed + 1.5, // Forward momentum
                vy: 0, // Natural drop (no upward toss)
                radius: 8,
                gravity: gravity,
                type: "bomb"
              });
              // Reset cooldown for next pass or another bomb
              e.fireCooldown = (e.type === "jet" ? 3000 : 4000) + Math.random() * 2000;
            }
          }

          if (e.x > width + 100) {
            enemies.splice(i, 1);
          } else if (e.x > width - getIslandWidth() * 0.5 && e.type === "ship") {
            // Only ships deal collision damage now, or planes if they are very low
            enemies.splice(i, 1);
            takeDamage(10);
          }
        }

        // Missiles & Bombs
        for (let i = enemyMissiles.length - 1; i >= 0; i--) {
          const m = enemyMissiles[i];
          m.x += m.vx; m.y += m.vy;
          if (m.gravity) {
            m.vy += m.gravity;
            // Add smoke trail for bombs
            if (state.frame % 3 === 0) {
              particles.push({
                x: m.x, y: m.y,
                vx: (Math.random() - 0.5) * 1,
                vy: (Math.random() - 0.5) * 1,
                life: 0.6,
                decay: 0.02,
                size: 3,
                color: "rgba(200, 200, 200, 0.5)"
              });
            }
          }

          const islandStartX = width - getIslandWidth();
          const groundY = getSeaY() - 20; // Island surface level

          if (m.x > islandStartX && m.y > groundY) {
            // Hit the island
            enemyMissiles.splice(i, 1);
            takeDamage(m.type === "bomb" ? 8 : 5);
          } else if (m.y > getSeaY()) {
            // Splash in water (only if not hitting island)
            createExplosion(m.x, m.y, "#2f7bc3", 5);
            enemyMissiles.splice(i, 1);
          }
        }

        // Gifts
        for (let i = gifts.length - 1; i >= 0; i--) {
          const g = gifts[i];
          g.y += g.speed;
          if (g.y > getSeaY()) gifts.splice(i, 1);
        }

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx; p.y += p.vy;
          p.life -= p.decay;
          if (p.life <= 0) particles.splice(i, 1);
        }

        // Popups
        for (let i = popups.length - 1; i >= 0; i--) {
          const p = popups[i];
          p.life -= 0.016;
          p.y -= 0.5;
          if (p.life <= 0) popups.splice(i, 1);
        }

        handleCollisions();
      }

      function takeDamage(amt) {
        state.baseHp -= amt;
        state.shake = 10;
        Sfx.play("damage");
        updateHud();
        if (state.baseHp <= 0) {
          state.gameOver = true;
          ui.gameOver.classList.add("show");
        }
      }

      function handleCollisions() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const p = projectiles[i];
          let hit = false;

          // Hit Enemy
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (distance(p, e) < p.radius + e.size) {
              e.hp -= p.damage;
              hit = true;
              if (p.splash) splashDamage(p, p.splash);
              if (e.hp <= 0) {
                createExplosion(e.x, e.y, "#f87171", 20);
                addMoney(e.reward, e.x, e.y);
                enemies.splice(j, 1);
              }
              break;
            }
          }

          // Hit Missile
          if (!hit) {
            for (let j = enemyMissiles.length - 1; j >= 0; j--) {
              const m = enemyMissiles[j];
              if (distance(p, m) < p.radius + m.radius) {
                createExplosion(m.x, m.y, "#ffaa00", 10);
                addMoney(1, m.x, m.y);
                enemyMissiles.splice(j, 1);
                hit = true;
                break;
              }
            }
          }

          // Hit Launcher
          if (!hit && state.launcherAlive) {
            const l = getLauncherPos();
            if (distance(p, l) < p.radius + 30) {
              state.launcherHp -= p.damage;
              hit = true;
              if (state.launcherHp <= 0) {
                state.launcherAlive = false;
                state.launcherCooldown = 10000;
                createExplosion(l.x, l.y, "#ef4444", 40);
                addMoney(5, l.x, l.y);
                updateHud();
              }
            }
          }

          // Hit Gift
          if (!hit) {
            for (let j = gifts.length - 1; j >= 0; j--) {
              const g = gifts[j];
              if (distance(p, g) < p.radius + g.size) {
                createExplosion(g.x, g.y, "#fbbf24", 15);
                if (Math.random() > 0.6) {
                  state.itemReady = true;
                  popups.push({ x: g.x, y: g.y, text: "SPECIAL WEAPON!", life: 1.5, color: "#4ade80", size: 20 });
                } else {
                  addMoney(10, g.x, g.y);
                }
                gifts.splice(j, 1);
                hit = true;
                updateHud();
                break;
              }
            }
          }

          if (hit) projectiles.splice(i, 1);
        }
      }

      function splashDamage(p, radius) {
        enemies.forEach((e, idx) => {
          if (distance(p, e) < radius) {
            e.hp -= 8;
            if (e.hp <= 0) {
              createExplosion(e.x, e.y, "#f87171", 15);
              addMoney(e.reward, e.x, e.y);
              enemies.splice(idx, 1);
            }
          }
        });
      }

      function distance(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }

      function draw() {
        ctx.save();
        if (state.shake > 0.1) ctx.translate(Math.random() * state.shake, Math.random() * state.shake);
        
        ctx.clearRect(0, 0, width, height);
        drawBackground();
        
        clouds.forEach(drawCloud);
        drawIslands();
        drawLauncher();
        drawTurret();

        enemies.forEach(drawEnemy);
        gifts.forEach(drawGift);
        enemyMissiles.forEach(drawMissile);
        projectiles.forEach(drawProjectile);
        particles.forEach(drawParticle);
        drawPopups();
        drawBaseHpBar();
        drawTarget();

        ctx.restore();
      }

      function drawBaseHpBar() {
        const iw = getIslandWidth();
        const seaY = getSeaY();
        const x = width - iw * 0.5;
        const y = seaY - 140;
        const barW = 120;
        const barH = 10;
        
        const hpRatio = Math.max(0, state.baseHp / state.maxHp);
        
        ctx.save();
        ctx.translate(x - barW / 2, y);
        
        // Background/Border
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(-2, -2, barW + 4, barH + 4);
        
        // HP Fill (Color changes based on health)
        let color = "#4ade80"; // Green
        if (hpRatio < 0.3) color = "#ef4444"; // Red
        else if (hpRatio < 0.6) color = "#fbbf24"; // Yellow
        
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, barW * hpRatio, barH);
        
        // Label
        ctx.fillStyle = "white";
        ctx.font = "bold 12px Oxanium";
        ctx.textAlign = "center";
        ctx.fillText("BASE INTEGRITY", barW / 2, -8);
        
        ctx.restore();
      }

      function drawTarget() {
        const { x, y } = state.aim;
        const size = 15;
        
        ctx.save();
        ctx.translate(x, y);
        
        ctx.strokeStyle = "#ff4444";
        ctx.lineWidth = 2;
        
        // Target circle
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.stroke();
        
        // Crosshair lines
        ctx.beginPath();
        ctx.moveTo(-size - 5, 0); ctx.lineTo(-size + 5, 0);
        ctx.moveTo(size + 5, 0); ctx.lineTo(size - 5, 0);
        ctx.moveTo(0, -size - 5); ctx.lineTo(0, -size + 5);
        ctx.moveTo(0, size + 5); ctx.lineTo(0, size - 5);
        ctx.stroke();
        
        // Center dot
        ctx.fillStyle = "#ff4444";
        ctx.beginPath();
        ctx.arc(0, 0, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }

      function drawBackground() {
        const seaY = getSeaY();
        const grad = ctx.createLinearGradient(0, 0, 0, seaY);
        grad.addColorStop(0, "#1e293b");
        grad.addColorStop(1, "#334155");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, seaY);

        const seaGrad = ctx.createLinearGradient(0, seaY, 0, height);
        seaGrad.addColorStop(0, "#0f172a");
        seaGrad.addColorStop(1, "#1e293b");
        ctx.fillStyle = seaGrad;
        ctx.fillRect(0, seaY, width, height - seaY);

        // Simple waves
        ctx.strokeStyle = "rgba(255,255,255,0.05)";
        ctx.lineWidth = 2;
        for(let i=0; i<5; i++) {
          const y = seaY + 15 + i*15;
          const off = (state.frame * 0.5 + i * 50) % 200;
          ctx.beginPath();
          for(let x=-off; x<width; x+=100) {
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(x+25, y-5, x+50, y);
            ctx.quadraticCurveTo(x+75, y+5, x+100, y);
          }
          ctx.stroke();
        }
      }

      function drawCloud(c) {
        ctx.fillStyle = "rgba(255,255,255,0.08)";
        ctx.beginPath();
        ctx.arc(c.x, c.y, 30 * c.scale, 0, Math.PI * 2);
        ctx.arc(c.x + 40 * c.scale, c.y + 10 * c.scale, 25 * c.scale, 0, Math.PI * 2);
        ctx.arc(c.x - 30 * c.scale, c.y + 10 * c.scale, 20 * c.scale, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawIslands() {
        const seaY = getSeaY();
        const iw = getIslandWidth();
        
        // Enemy Island
        ctx.fillStyle = "#3e2723";
        ctx.beginPath();
        ctx.moveTo(0, seaY);
        ctx.lineTo(iw, seaY);
        ctx.lineTo(iw * 0.8, seaY - 80);
        ctx.lineTo(iw * 0.4, seaY - 120);
        ctx.lineTo(0, seaY - 40);
        ctx.fill();
        ctx.fillStyle = "#4e342e";
        ctx.fillRect(0, seaY - 10, iw, 10);

        // Player Island
        ctx.fillStyle = "#1b5e20";
        ctx.beginPath();
        ctx.moveTo(width, seaY);
        ctx.lineTo(width - iw, seaY);
        ctx.lineTo(width - iw * 0.9, seaY - 70);
        ctx.lineTo(width - iw * 0.5, seaY - 110);
        ctx.lineTo(width, seaY - 80);
        ctx.fill();
        ctx.fillStyle = "#2e7d32";
        ctx.fillRect(width - iw, seaY - 10, iw, 10);
      }

      function drawTurret() {
        const p = getTurretPos();
        const angle = Math.atan2(state.aim.y - p.y, state.aim.x - p.x);
        
        ctx.save();
        ctx.translate(p.x, p.y);
        // Base
        ctx.fillStyle = "#334155";
        ctx.beginPath();
        ctx.arc(0, 0, 25, Math.PI, 0);
        ctx.fill();
        // Barrel
        ctx.rotate(angle);
        ctx.fillStyle = "#64748b";
        ctx.fillRect(0, -6, 45, 12);
        ctx.strokeStyle = "#94a3b8";
        ctx.lineWidth = 2;
        ctx.strokeRect(0, -6, 45, 12);
        ctx.restore();
      }

      function drawLauncher() {
        const p = getLauncherPos();
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.fillStyle = state.launcherAlive ? "#991b1b" : "#451a03";
        ctx.fillRect(-25, -15, 50, 30);
        ctx.fillStyle = "#1e1b4b";
        ctx.fillRect(-15, -40, 30, 25);
        if (state.launcherAlive) {
          ctx.strokeStyle = "#ef4444";
          ctx.strokeRect(-25, -15, 50, 30);
          // Missile tip peeking out
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.moveTo(0, -45); ctx.lineTo(10, -35); ctx.lineTo(-10, -35);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawEnemy(e) {
        ctx.save();
        ctx.translate(e.x, e.y);
        if (e.type === "ship") {
          ctx.fillStyle = "#475569";
          ctx.beginPath();
          ctx.moveTo(-35, 10); ctx.lineTo(35, 10); ctx.lineTo(25, -15); ctx.lineTo(-30, -15);
          ctx.fill();
          ctx.fillStyle = "#1e293b";
          ctx.fillRect(-10, -30, 20, 15);
        } else if (e.type === "heli") {
          ctx.fillStyle = "#fbbf24";
          ctx.beginPath();
          ctx.ellipse(0, 0, 20, 12, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = "#334155";
          ctx.fillRect(-25, -2, 15, 4);
          // Rotor
          ctx.strokeStyle = "#fff";
          const rotX = Math.cos(state.frame * 0.5) * 30;
          ctx.beginPath(); ctx.moveTo(-rotX, -15); ctx.lineTo(rotX, -15); ctx.stroke();
        } else {
          ctx.fillStyle = "#94a3b8";
          if (e.takingOff) ctx.rotate(-0.3); // Nose up during takeoff
          ctx.beginPath();
          ctx.moveTo(-25, 0); ctx.lineTo(20, -10); ctx.lineTo(25, 0); ctx.lineTo(20, 10);
          ctx.fill();
          ctx.fillStyle = "#ef4444";
          ctx.fillRect(-15, -2, 5, 4);
          // Engine flame
          if (state.frame % 4 < 2) {
            ctx.fillStyle = "#fbbf24";
            ctx.beginPath(); ctx.moveTo(-25, -5); ctx.lineTo(-40, 0); ctx.lineTo(-25, 5); ctx.fill();
          }
        }
        // HP mini bar
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(-20, 15, 40, 4);
        ctx.fillStyle = "#4ade80";
        ctx.fillRect(-20, 15, 40 * (e.hp / (e.type === 'ship' ? 12 : e.type === 'heli' ? 8 : 6)), 4);
        ctx.restore();
      }

      function drawMissile(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        if (m.type === "bomb") {
          ctx.fillStyle = "#334155";
          ctx.beginPath(); ctx.arc(0, 0, m.radius, 0, Math.PI * 2); ctx.fill();
          // Fuse/Top
          ctx.fillStyle = "#ef4444";
          ctx.fillRect(-2, -m.radius - 2, 4, 4);
        } else {
          ctx.rotate(Math.atan2(m.vy, m.vx));
          ctx.fillStyle = "#ef4444";
          ctx.beginPath();
          ctx.moveTo(10, 0); ctx.lineTo(-10, -5); ctx.lineTo(-10, 5);
          ctx.fill();
          ctx.fillStyle = "#fbbf24";
          ctx.beginPath(); ctx.arc(-12, 0, 4, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
      }

      function drawGift(g) {
        ctx.save();
        ctx.translate(g.x, g.y);
        ctx.rotate(state.frame * 0.02);
        ctx.fillStyle = "#ef4444";
        ctx.fillRect(-15, -15, 30, 30);
        ctx.fillStyle = "#fbbf24";
        ctx.fillRect(-15, -3, 30, 6);
        ctx.fillRect(-3, -15, 6, 30);
        ctx.restore();
      }

      function drawProjectile(p) {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.fillStyle = p.color;
        if (p.type === "super") {
          const glow = ctx.createRadialGradient(0,0,0,0,0,p.radius*2);
          glow.addColorStop(0, p.color);
          glow.addColorStop(1, "transparent");
          ctx.fillStyle = glow;
          ctx.beginPath(); ctx.arc(0,0,p.radius*2,0,Math.PI*2); ctx.fill();
        }
        ctx.beginPath(); ctx.arc(0, 0, p.radius, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      }

      function drawParticle(p) {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
      }

      function drawPopups() {
        popups.forEach(p => {
          ctx.save();
          ctx.globalAlpha = p.life;
          ctx.fillStyle = p.color;
          ctx.font = `bold ${p.size}px Oxanium`;
          ctx.textAlign = "center";
          ctx.fillText(p.text, p.x, p.y);
          ctx.restore();
        });
      }

      function restart() {
        Object.assign(state, {
          money: 0, baseHp: 100, gunLevel: 1, gunCooldown: 0, cannonCooldown: 0,
          itemReady: false, launcherAlive: true, launcherHp: 6, launcherCooldown: 0,
          gameOver: false, shake: 0
        });
        projectiles.length = 0; enemies.length = 0; gifts.length = 0;
        enemyMissiles.length = 0; popups.length = 0; particles.length = 0;
        ui.gameOver.classList.remove("show");
        updateHud();
      }

      function loop(t) {
        const delta = Math.min(32, t - state.lastTime || 16);
        state.lastTime = t;
        update(delta);
        draw();
        requestAnimationFrame(loop);
      }

      updateHud();
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
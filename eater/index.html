<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Black Hole Eater - Arcade</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@800&family=Space+Grotesk:wght@700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-purple: #bc13fe;
            --bg-dark: #010108;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-dark);
            font-family: 'Plus Jakarta Sans', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            touch-action: none;
        }

        #top-bar {
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            z-index: 15;
            position: fixed;
            top: 0;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--neon-blue);
        }

        .stat-value {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 18px;
            font-weight: 700;
        }

        /* Leaderboard & Log Styles */
        #leaderboard {
            position: fixed;
            top: 70px;
            left: 20px;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 12px;
            border-left: 3px solid var(--neon-blue);
            backdrop-filter: blur(10px);
            z-index: 10;
            min-width: 150px;
        }

        .leaderboard-title {
            font-size: 10px;
            color: var(--neon-blue);
            text-transform: uppercase;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 4px;
            color: rgba(255, 255, 255, 0.8);
        }

        .leaderboard-item.is-player {
            color: var(--neon-blue);
            font-weight: bold;
        }

        #game-log {
            position: fixed;
            top: 70px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            pointer-events: none;
            z-index: 10;
        }

        .log-entry {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 12px;
            border-right: 3px solid var(--neon-purple);
            animation: slideIn 0.3s ease-out, fadeOut 0.5s ease-in 2.5s forwards;
            color: white;
            white-space: nowrap;
        }

        @keyframes slideIn {
            from { transform: translateX(50px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        #announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
            display: none;
        }

        .announce-title {
            font-size: 60px;
            font-weight: 800;
            color: var(--neon-blue);
            text-shadow: 0 0 20px var(--neon-blue);
            margin-bottom: 10px;
            animation: bounceIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .announce-subtitle {
            font-size: 30px;
            color: var(--neon-purple);
            text-shadow: 0 0 10px var(--neon-purple);
            animation: slideUp 0.5s ease-out 0.5s both;
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        @keyframes slideUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: default;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #screens {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: none;
        }

        .screen {
            background: rgba(1, 1, 8, 0.95);
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            border: 1px solid var(--neon-purple);
            box-shadow: 0 0 50px rgba(188, 19, 254, 0.2);
            display: none;
            flex-direction: column;
            gap: 20px;
            max-width: 90%;
            pointer-events: auto;
        }

        .screen.active {
            display: flex;
        }

        h2 {
            font-size: 42px;
            background: linear-gradient(to right, var(--neon-blue), var(--neon-purple));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 10px 0;
        }

        .diff-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        .diff-btn.active {
            background: var(--neon-purple);
            border-color: var(--neon-purple);
            box-shadow: 0 0 15px var(--neon-purple);
        }

        .btn {
            padding: 18px 50px;
            background: var(--neon-blue);
            color: var(--bg-dark);
            border: none;
            border-radius: 15px;
            font-size: 20px;
            font-weight: 800;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #mobile-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            text-align: center;
            pointer-events: none;
        }

        #joystick-container {
            position: fixed;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: none;
            touch-action: none;
            z-index: 30;
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: var(--neon-blue);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px var(--neon-blue);
            pointer-events: none;
        }

        @media (max-width: 768px) {
            #joystick-container {
                display: block;
            }
        }

        .back-btn {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            text-decoration: none;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 12px;
            border-radius: 15px;
            font-family: sans-serif;
            font-size: 12px;
            transition: background 0.3s;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .back-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }
    </style>
</head>

<body>
    <a href="../" class="back-btn">‚Üê Arcade</a>
    <div id="top-bar">
        <div class="stat-item">
            <span class="stat-label">Mass</span>
            <span id="score" class="stat-value">100</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Stage</span>
            <span id="stage-display" class="stat-value">1</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Difficulty</span>
            <span id="current-diff-display" class="stat-value"
                style="font-size: 12px; color: var(--neon-purple);">NORMAL</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Best Mass</span>
            <span id="best-score" class="stat-value">0</span>
        </div>
    </div>

    <div id="leaderboard">
        <div class="leaderboard-title">Top Celestials</div>
        <div id="leaderboard-list"></div>
    </div>

    <div id="game-log"></div>

    <div id="announcement">
        <div id="announce-title" class="announce-title">MISSION CLEAR</div>
        <div id="announce-subtitle" class="announce-subtitle">STAGE 2 START!</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="screens">
            <div id="start-screen" class="screen active">
                <h2>BLACK HOLE EATER</h2>
                <div class="difficulty-selector">
                    <button class="diff-btn" onclick="setDifficulty('easy')">EASY</button>
                    <button class="diff-btn active" onclick="setDifficulty('normal')">NORMAL</button>
                    <button class="diff-btn" onclick="setDifficulty('hard')">HARD</button>
                </div>
                <p style="opacity: 0.7;">Absorb smaller objects to grow. Avoid larger ones.</p>
                <button class="btn" onclick="startGame()">SINGULARITY</button>
            </div>

            <div id="game-over-screen" class="screen">
                <h2>COLLAPSED</h2>
                <p>You were absorbed by a larger celestial body.</p>
                <div style="margin: 10px 0;">
                    <div class="stat-label">Final Mass</div>
                    <div id="final-score" class="stat-value">0</div>
                </div>
                <button class="btn" onclick="startGame()">REGENERATE</button>
            </div>
        </div>
    </div>

    <div id="joystick-container">
        <div id="joystick-knob"></div>
    </div>

    <div id="mobile-hint">Use WASD, Arrows, or Joystick to navigate</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const bestScoreEl = document.getElementById('best-score');
        const finalScoreEl = document.getElementById('final-score');
        const joystickContainer = document.getElementById('joystick-container');
        const joystickKnob = document.getElementById('joystick-knob');

        // Game Constants
        const INITIAL_RADIUS = 10;
        const FOOD_COUNT = 150;
        const ENEMY_COUNT = 15;
        const WORLD_SIZE = 3000;
        const CELESTIAL_NAMES = [
            'Sirius', 'Canopus', 'Arcturus', 'Vega', 'Capella', 'Rigel', 'Procyon', 'Achernar', 
            'Betelgeuse', 'Hadar', 'Altair', 'Aldebaran', 'Antares', 'Spica', 'Pollux', 'Fomalhaut',
            'Deneb', 'Mimosa', 'Regulus', 'Adhara', 'Castor', 'Gacrux', 'Shaula'
        ];

        const DIFFICULTIES = {
            easy: { enemySpeed: 1.5, foodValue: 2, label: 'EASY' },
            normal: { enemySpeed: 2.5, foodValue: 1.5, label: 'NORMAL' },
            hard: { enemySpeed: 4.0, foodValue: 1.0, label: 'HARD' }
        };

        // Game State
        let currentDifficulty = 'normal';
        let gameActive = false;
        let lastTime = performance.now();
        let currentStage = 1;
        let isTransitioning = false;

        let player = {
            name: 'Singularity',
            x: WORLD_SIZE / 2,
            y: WORLD_SIZE / 2,
            radius: INITIAL_RADIUS,
            vx: 0,
            vy: 0
        };

        let food = [];
        let enemies = [];
        let camera = { x: 0, y: 0 };
        let keys = {};
        let joystick = { active: false, x: 0, y: 0 };

        function addLog(msg) {
            const logContainer = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerText = msg;
            logContainer.prepend(entry);
            setTimeout(() => entry.remove(), 3000);
        }

        function setDifficulty(diff) {
            currentDifficulty = diff;
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.classList.toggle('active', btn.innerText.toLowerCase() === diff);
            });
            document.getElementById('current-diff-display').innerText = DIFFICULTIES[diff].label;
            updateBestScoreDisplay();
        }

        function updateBestScoreDisplay() {
            const best = localStorage.getItem(`eater_best_${currentDifficulty}`) || 0;
            bestScoreEl.innerText = best;
        }

        function spawnFood() {
            while (food.length < FOOD_COUNT) {
                food.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    radius: Math.random() * 4 + 2,
                    color: `hsl(${Math.random() * 360}, 70%, 70%)`
                });
            }
        }

        function spawnEnemy(isInitial = false) {
            const minMass = 100;
            const maxMass = 2000 * Math.pow(2, currentStage - 1);
            const randomMass = minMass + Math.random() * (maxMass - minMass);
            const radius = Math.sqrt(randomMass);
            let x, y;

            // Spawn far from player
            do {
                x = Math.random() * WORLD_SIZE;
                y = Math.random() * WORLD_SIZE;
            } while (Math.hypot(x - player.x, y - player.y) < 800);

            const name = CELESTIAL_NAMES[Math.floor(Math.random() * CELESTIAL_NAMES.length)];
            const enemy = {
                name,
                x, y,
                radius,
                color: '#ff3e3e',
                vx: (Math.random() - 0.5),
                vy: (Math.random() - 0.5)
            };

            if (isInitial) enemies.push(enemy);
            else return enemy;
        }

        function initGame() {
            currentStage = 1;
            document.getElementById('stage-display').innerText = currentStage;
            player.radius = INITIAL_RADIUS;
            player.x = WORLD_SIZE / 2;
            player.y = WORLD_SIZE / 2;
            player.vx = 0;
            player.vy = 0;

            food = [];
            spawnFood();

            enemies = [];
            for (let i = 0; i < ENEMY_COUNT; i++) {
                spawnEnemy(true);
            }

            scoreEl.innerText = Math.floor(player.radius * player.radius);
            updateBestScoreDisplay();
            lastTime = performance.now();
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resize);
        resize();

        function startGame() {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            initGame();
            gameActive = true;
        }

        function gameOver() {
            gameActive = false;
            const finalMass = Math.floor(player.radius * player.radius);
            finalScoreEl.innerText = finalMass;
            const bestKey = `eater_best_${currentDifficulty}`;
            const best = parseInt(localStorage.getItem(bestKey) || 0);
            if (finalMass > best) {
                localStorage.setItem(bestKey, finalMass);
                bestScoreEl.innerText = finalMass;
            }
            document.getElementById('game-over-screen').classList.add('active');
        }

        function update(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            const f = Math.min(deltaTime / (1000 / 60), 3);

            if (gameActive) {
                const config = DIFFICULTIES[currentDifficulty];

                // Handle Input (Keyboard and Joystick)
                let inputX = 0;
                let inputY = 0;

                if (joystick.active) {
                    inputX = joystick.x;
                    inputY = joystick.y;
                } else {
                    if (keys['ArrowUp'] || keys['w'] || keys['W']) inputY -= 1;
                    if (keys['ArrowDown'] || keys['s'] || keys['S']) inputY += 1;
                    if (keys['ArrowLeft'] || keys['a'] || keys['A']) inputX -= 1;
                    if (keys['ArrowRight'] || keys['d'] || keys['D']) inputX += 1;
                    
                    // Normalize keyboard diagonal
                    const mag = Math.hypot(inputX, inputY);
                    if (mag > 1) {
                        inputX /= mag;
                        inputY /= mag;
                    }
                }

                const maxSpeed = 20 / Math.sqrt(player.radius);
                if (inputX !== 0 || inputY !== 0) {
                    const targetVx = inputX * maxSpeed;
                    const targetVy = inputY * maxSpeed;
                    
                    // Acceleration
                    player.vx += (targetVx - player.vx) * 0.15 * f;
                    player.vy += (targetVy - player.vy) * 0.15 * f;
                } else {
                    // Friction/Deceleration
                    player.vx *= Math.pow(0.92, f);
                    player.vy *= Math.pow(0.92, f);
                    if (Math.abs(player.vx) < 0.01) player.vx = 0;
                    if (Math.abs(player.vy) < 0.01) player.vy = 0;
                }

                player.x += player.vx * f;
                player.y += player.vy * f;

                // Keep in world bounds
                player.x = Math.max(player.radius, Math.min(WORLD_SIZE - player.radius, player.x));
                player.y = Math.max(player.radius, Math.min(WORLD_SIZE - player.radius, player.y));
                
                // If hit world bound, stop velocity
                if (player.x === player.radius || player.x === WORLD_SIZE - player.radius) player.vx = 0;
                if (player.y === player.radius || player.y === WORLD_SIZE - player.radius) player.vy = 0;

                // Update Leaderboard
                if (Math.floor(timestamp / 500) !== Math.floor((timestamp - deltaTime) / 500)) {
                    updateLeaderboard();
                }

                // Camera follow player
                camera.x = player.x - canvas.width / 2;
                camera.y = player.y - canvas.height / 2;

                // Food collision
                food = food.filter(f => {
                    const d = Math.hypot(player.x - f.x, player.y - f.y);
                    if (d < player.radius) {
                        player.radius = Math.sqrt(player.radius * player.radius + f.radius * f.radius * config.foodValue);
                        scoreEl.innerText = Math.floor(player.radius * player.radius);
                        return false;
                    }
                    return true;
                });
                spawnFood();

                // Enemy updates
                for (let i = 0; i < enemies.length; i++) {
                    const en = enemies[i];
                    
                    // Move enemy based on their mass (speed = 20 / sqrt(radius))
                    const enemyMaxSpeed = (20 / Math.sqrt(en.radius)) * (config.enemySpeed / 2.5);
                    en.x += en.vx * (enemyMaxSpeed + currentStage * 0.2) * f;
                    en.y += en.vy * (enemyMaxSpeed + currentStage * 0.2) * f;

                    // Bounce off walls
                    if (en.x < en.radius || en.x > WORLD_SIZE - en.radius) en.vx *= -1;
                    if (en.y < en.radius || en.y > WORLD_SIZE - en.radius) en.vy *= -1;

                    // Interaction with player
                    const d = Math.hypot(player.x - en.x, player.y - en.y);
                    if (d < Math.max(player.radius, en.radius)) {
                        if (player.radius > en.radius) {
                            // Player eats enemy
                            addLog(`You consumed ${en.name}`);
                            player.radius = Math.sqrt(player.radius * player.radius + en.radius * en.radius);
                            scoreEl.innerText = Math.floor(player.radius * player.radius);
                            enemies.splice(i, 1);
                            i--;
                            continue;
                        } else if (en.radius > player.radius) {
                            // Enemy eats player
                            addLog(`${en.name} absorbed you`);
                            gameOver();
                            return;
                        }
                    }

                    // Interaction with other enemies
                    for (let j = i + 1; j < enemies.length; j++) {
                        const en2 = enemies[j];
                        const d2 = Math.hypot(en.x - en2.x, en.y - en2.y);
                        if (d2 < Math.max(en.radius, en2.radius)) {
                            if (en.radius > en2.radius) {
                                addLog(`${en.name} consumed ${en2.name}`);
                                en.radius = Math.sqrt(en.radius * en.radius + en2.radius * en2.radius);
                                enemies.splice(j, 1);
                                j--;
                            } else if (en2.radius > en.radius) {
                                addLog(`${en2.name} consumed ${en.name}`);
                                en2.radius = Math.sqrt(en2.radius * en2.radius + en.radius * en.radius);
                                enemies.splice(i, 1);
                                i--;
                                break;
                            }
                        }
                    }
                }

                // Stage Clear Logic
                if (enemies.length === 0 && gameActive) {
                    nextStage();
                }
            }

            draw();
            requestAnimationFrame(update);
        }

        function nextStage() {
            if (isTransitioning) return;
            isTransitioning = true;
            
            // Show Announcement
            const announce = document.getElementById('announcement');
            const title = document.getElementById('announce-title');
            const subtitle = document.getElementById('announce-subtitle');
            
            title.innerText = "MISSION CLEAR";
            subtitle.innerText = `STAGE ${currentStage + 1} START!`;
            announce.style.display = 'block';

            addLog(`Rank 1 Achieved! Stage ${currentStage} Clear!`);

            setTimeout(() => {
                currentStage++;
                document.getElementById('stage-display').innerText = currentStage;
                
                // Spawn new set of enemies for next stage
                enemies = [];
                const count = ENEMY_COUNT + (currentStage - 1) * 2;
                for (let i = 0; i < count; i++) {
                    enemies.push(spawnEnemy());
                }
                
                spawnFood();
                announce.style.display = 'none';
                isTransitioning = false;
            }, 3000);
        }

        function updateLeaderboard() {
            const list = [...enemies, player]
                .sort((a, b) => b.radius - a.radius);
            
            // Check for Rank 1 Stage Clear
            if (gameActive && !isTransitioning && list[0] === player && enemies.length > 0) {
                nextStage();
            }

            const container = document.getElementById('leaderboard-list');
            container.innerHTML = list.slice(0, 5).map((item, idx) => `
                <div class="leaderboard-item ${item === player ? 'is-player' : ''}">
                    <span>${idx + 1}. ${item.name}</span>
                    <span>${Math.floor(item.radius * item.radius)}</span>
                </div>
            `).join('');
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // World Boundary
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 10;
            ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);

            // Grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= WORLD_SIZE; i += 100) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, WORLD_SIZE); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(WORLD_SIZE, i); ctx.stroke();
            }

            // Food
            food.forEach(f => {
                ctx.fillStyle = f.color;
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Enemies
            enemies.forEach(en => {
                const gradient = ctx.createRadialGradient(en.x, en.y, 0, en.x, en.y, en.radius);
                gradient.addColorStop(0, '#000');
                gradient.addColorStop(0.8, en.color);
                gradient.addColorStop(1, 'rgba(255, 62, 62, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(en.x, en.y, en.radius * 1.2, 0, Math.PI * 2);
                ctx.fill();

                // Red Glow
                ctx.strokeStyle = en.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(en.x, en.y, en.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Enemy Name Tag
                ctx.fillStyle = 'white';
                ctx.font = `bold ${Math.max(12, en.radius / 2)}px 'Space Grotesk'`;
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.shadowColor = 'black';
                ctx.fillText(en.name, en.x, en.y - en.radius - 10);
                ctx.shadowBlur = 0;
            });

            // Player (Black Hole)
            const pX = player.x;
            const pY = player.y;
            const r = player.radius;

            // Event Horizon Glow
            const glow = ctx.createRadialGradient(pX, pY, r * 0.8, pX, pY, r * 1.5);
            glow.addColorStop(0, 'rgba(0, 243, 255, 0.5)');
            glow.addColorStop(1, 'rgba(188, 19, 254, 0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(pX, pY, r * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Singularity
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(pX, pY, r, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#00f3ff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(pX, pY, r, 0, Math.PI * 2);
            ctx.stroke();

            // Player Name Tag
            ctx.fillStyle = '#00f3ff';
            ctx.font = `bold ${Math.max(14, r / 2)}px 'Space Grotesk'`;
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'black';
            ctx.fillText(player.name, pX, pY - r - 15);
            ctx.shadowBlur = 0;

            ctx.restore();
        }

        // Controls
        // Removed mouse/touch follow controls in favor of WASD/Arrows/Joystick

        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (!gameActive && document.querySelector('.screen.active')) {
                startGame();
            }
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
        });

        // Virtual Joystick Logic
        joystickContainer.addEventListener('touchstart', e => {
            joystick.active = true;
            updateJoystick(e.touches[0]);
        });
        window.addEventListener('touchmove', e => {
            if (joystick.active) {
                updateJoystick(e.touches[0]);
            }
        });
        window.addEventListener('touchend', () => {
            joystick.active = false;
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            joystick.x = 0;
            joystick.y = 0;
        });

        function updateJoystick(touch) {
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const dist = Math.hypot(dx, dy);
            const maxDist = rect.width / 2;

            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }

            joystick.x = dx / maxDist;
            joystick.y = dy / maxDist;

            joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        }

        updateBestScoreDisplay();
        requestAnimationFrame(update);
    </script>
</body>

</html>
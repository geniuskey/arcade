<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Planet Match - Arcade</title>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@800&family=Space+Grotesk:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-purple: #bc13fe;
            --neon-pink: #ff00ff;
            --bg-dark: #020010;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-dark);
            font-family: 'Plus Jakarta Sans', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            touch-action: none;
        }

        #top-bar {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            z-index: 15;
            position: fixed;
            top: 0;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--neon-blue);
        }

        .stat-value {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 18px;
            font-weight: 700;
        }

        #game-container {
            position: relative;
            width: min(90vw, 450px);
            aspect-ratio: 1/1;
            background: rgba(255, 255, 255, 0.02);
            border: 6px solid rgba(255, 255, 255, 0.12);
            border-radius: 20px;
            padding: 8px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 4px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .tile {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.2s;
            touch-action: none;
        }

        .tile.selected {
            background: rgba(0, 243, 255, 0.2);
        }

        .planet {
            position: relative;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            pointer-events: none;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
        }

        /* Bomb Emojis */
        .planet.bomb-h::after { content: 'üöÄ'; position: absolute; filter: drop-shadow(0 0 5px white); }
        .planet.bomb-v::after { content: 'üõ∞Ô∏è'; position: absolute; filter: drop-shadow(0 0 5px white); }
        .planet.bomb-5::after { content: 'üí£'; position: absolute; filter: drop-shadow(0 0 5px white); }

        @keyframes combo-up {
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -50px) scale(1.2); opacity: 1; }
            80% { transform: translate(-50%, -60px) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -100px) scale(0.8); opacity: 0; }
        }

        .combo-text {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 800;
            font-size: 40px;
            color: var(--neon-pink);
            text-shadow: 0 0 20px var(--neon-pink), 0 0 10px white;
            pointer-events: none;
            z-index: 200;
            animation: combo-up 1s ease-out forwards;
        }

        #timer-bar-container {
            width: min(90vw, 450px);
            height: 6px;
            background: #222;
            border-radius: 3px;
            margin-top: 20px;
            overflow: hidden;
        }

        #timer-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, var(--neon-blue), var(--neon-purple));
            transition: width 0.1s linear;
        }

        #screens {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.4);
        }

        .screen {
            background: rgba(2, 0, 16, 0.95);
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            border: 1px solid var(--neon-purple);
            box-shadow: 0 0 50px rgba(188, 19, 254, 0.2);
            display: none;
            flex-direction: column;
            gap: 20px;
            max-width: 90%;
            pointer-events: auto;
        }

        .screen.active {
            display: flex;
        }

        h2 {
            font-size: 32px;
            background: linear-gradient(to right, var(--neon-blue), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 10px 0;
        }

        .diff-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        .diff-btn.active {
            background: var(--neon-purple);
            border-color: var(--neon-purple);
            box-shadow: 0 0 15px var(--neon-purple);
        }

        .btn {
            padding: 15px 40px;
            background: var(--neon-blue);
            color: var(--bg-dark);
            border: none;
            border-radius: 15px;
            font-size: 20px;
            font-weight: 800;
            cursor: pointer;
            transition: transform 0.2s;
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(0); opacity: 0; }
        }

        .pop-anim {
            animation: pop 0.3s ease-out forwards;
        }
    </style>
</head>
<body>
    <div id="top-bar">
        <div class="stat-item">
            <span class="stat-label">Score</span>
            <span id="score" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Difficulty</span>
            <span id="current-diff-display" class="stat-value" style="font-size: 12px; color: var(--neon-purple);">NORMAL</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Best</span>
            <span id="best-score" class="stat-value">0</span>
        </div>
    </div>

    <div id="game-container"></div>

    <div id="timer-bar-container">
        <div id="timer-fill"></div>
    </div>

    <div id="screens">
        <div id="start-screen" class="screen active">
            <h2>PLANET MATCH</h2>
            <div class="difficulty-selector">
                <button class="diff-btn" onclick="setDifficulty('easy')">EASY</button>
                <button class="diff-btn active" onclick="setDifficulty('normal')">NORMAL</button>
                <button class="diff-btn" onclick="setDifficulty('hard')">HARD</button>
            </div>
            <p style="opacity: 0.7;">Match 3 or more planets to clear them before time runs out!</p>
            <button class="btn" onclick="startGame()">SYNCHRONIZE</button>
        </div>

        <div id="game-over-screen" class="screen">
            <h2>ORBIT DECAYED</h2>
            <p>The cosmic alignment has ended.</p>
            <div style="margin: 10px 0;">
                <div class="stat-label">Final Score</div>
                <div id="final-score" class="stat-value">0</div>
            </div>
            <button class="btn" onclick="startGame()">RE-ALIGN</button>
        </div>
    </div>

    <script>
        const container = document.getElementById('game-container');
        const scoreEl = document.getElementById('score');
        const bestScoreEl = document.getElementById('best-score');
        const finalScoreEl = document.getElementById('final-score');
        const timerFill = document.getElementById('timer-fill');

        const GRID_SIZE = 8;
        const PLANET_COLORS = [
            '#00f3ff', // Blue
            '#bc13fe', // Purple
            '#ff00ff', // Pink
            '#ff9d00', // Orange
            '#00ff00', // Green
            '#ff3e3e', // Red
            '#ffff00'  // Yellow
        ];

        const DIFFICULTIES = {
            easy: { colors: 5, time: 90, label: 'EASY' },
            normal: { colors: 6, time: 60, label: 'NORMAL' },
            hard: { colors: 7, time: 45, label: 'HARD' }
        };

        let currentDifficulty = 'normal';
        let score = 0;
        let gameActive = false;
        let grid = [];
        let selectedTile = null;
        let timeLeft = 60;
        let timerInterval;
        let comboCount = 0;

        function showComboText(count) {
            if (count < 2) return;
            const combo = document.createElement('div');
            combo.className = 'combo-text';
            const messages = ['', '', 'GREAT!', 'AMAZING!', 'COSMIC!', 'UNBELIEVABLE!', 'GODLIKE!'];
            const msg = messages[Math.min(count, messages.length - 1)];
            combo.innerText = `COMBO ${count}\n${msg}`;
            document.body.appendChild(combo);
            setTimeout(() => combo.remove(), 1000);
        }

        function setDifficulty(diff) {
            currentDifficulty = diff;
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.classList.toggle('active', btn.innerText.toLowerCase() === diff);
            });
            document.getElementById('current-diff-display').innerText = DIFFICULTIES[diff].label;
            updateBestScoreDisplay();
        }

        function updateBestScoreDisplay() {
            const best = localStorage.getItem(`match_best_${currentDifficulty}`) || 0;
            bestScoreEl.innerText = best;
        }

        function initGrid() {
            container.innerHTML = '';
            grid = [];
            const config = DIFFICULTIES[currentDifficulty];

            for (let r = 0; r < GRID_SIZE; r++) {
                grid[r] = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    let colorIdx;
                    do {
                        colorIdx = Math.floor(Math.random() * config.colors);
                    } while (
                        (c >= 2 && grid[r][c-1].colorIdx === colorIdx && grid[r][c-2].colorIdx === colorIdx) ||
                        (r >= 2 && grid[r-1][c].colorIdx === colorIdx && grid[r-2][c].colorIdx === colorIdx)
                    );

                    const tile = createTile(r, c, colorIdx);
                    grid[r][c] = { r, c, colorIdx, el: tile, bomb: null };
                    container.appendChild(tile);
                }
            }
        }

        function createTile(r, c, colorIdx) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.dataset.r = r;
            tile.dataset.c = c;
            
            tile.onpointerdown = (e) => {
                if (!gameActive) return;
                tile.releasePointerCapture(e.pointerId);
                onTileSelect(r, c);
            };

            tile.onpointerenter = (e) => {
                if (!gameActive || !selectedTile) return;
                onTileSelect(r, c);
            };

            const planet = document.createElement('div');
            planet.className = 'planet';
            planet.style.background = PLANET_COLORS[colorIdx];
            planet.style.boxShadow = `0 0 10px ${PLANET_COLORS[colorIdx]}`;
            tile.appendChild(planet);

            return tile;
        }

        let lastMovedTile = null;

        async function onTileSelect(r, c) {
            if (!gameActive) return;

            const curr = grid[r][c];

            // Activate bomb if clicked
            if (curr.bomb) {
                comboCount = 0; // Reset combo for bomb action
                if (selectedTile) selectedTile.el.classList.remove('selected');
                selectedTile = null;
                await triggerBomb(curr);
                await refillGrid();
                await checkAndClearMatches();
                return;
            }

            if (!selectedTile) {
                selectedTile = curr;
                selectedTile.el.classList.add('selected');
            } else {
                const prev = selectedTile;
                
                if (prev === curr) return;

                const dr = Math.abs(prev.r - curr.r);
                const dc = Math.abs(prev.c - curr.c);

                if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
                    comboCount = 0; // Reset combo for new move
                    prev.el.classList.remove('selected');
                    selectedTile = null;
                    lastMovedTile = curr; // Track for bomb placement
                    await swapTiles(prev, curr);
                    if (!await checkAndClearMatches()) {
                        await swapTiles(prev, curr); // Swap back if no match
                    }
                } else {
                    // Select new tile if not adjacent
                    prev.el.classList.remove('selected');
                    selectedTile = curr;
                    selectedTile.el.classList.add('selected');
                }
            }
        }

        window.onpointerup = () => {
            // Cancel selection on global pointer up if dragging
            // But we keep it for click-click style too
        };

        async function triggerBomb(tile) {
            const type = tile.bomb;
            const r = tile.r;
            const c = tile.c;
            let toClear = [];

            if (type === 'h') {
                for (let i = 0; i < GRID_SIZE; i++) toClear.push(grid[r][i]);
            } else if (type === 'v') {
                for (let i = 0; i < GRID_SIZE; i++) toClear.push(grid[i][c]);
            } else if (type === '5') {
                for (let i = r - 2; i <= r + 2; i++) {
                    for (let j = c - 2; j <= c + 2; j++) {
                        if (grid[i] && grid[i][j]) toClear.push(grid[i][j]);
                    }
                }
            }

            tile.bomb = null;
            score += toClear.length * 15;
            scoreEl.innerText = score;

            toClear.forEach(m => m.el.querySelector('.planet').classList.add('pop-anim'));
            await new Promise(resolve => setTimeout(resolve, 300));
        }

        async function swapTiles(t1, t2) {
            const p1 = t1.el.querySelector('.planet');
            const p2 = t2.el.querySelector('.planet');

            const dx = (t2.c - t1.c) * 100;
            const dy = (t2.r - t1.r) * 100;

            // Visual move
            p1.style.transform = `translate(${dx}%, ${dy}%)`;
            p2.style.transform = `translate(${-dx}%, ${-dy}%)`;

            await new Promise(resolve => setTimeout(resolve, 200));

            // Actual data swap
            const tempIdx = t1.colorIdx;
            const tempBomb = t1.bomb;
            t1.colorIdx = t2.colorIdx;
            t1.bomb = t2.bomb;
            t2.colorIdx = tempIdx;
            t2.bomb = tempBomb;

            // Reset visual move and update colors
            p1.style.transition = 'none';
            p2.style.transition = 'none';
            p1.style.transform = '';
            p2.style.transform = '';
            updatePlanetStyle(t1);
            updatePlanetStyle(t2);
            
            // Force reflow
            p1.offsetHeight; 
            p1.style.transition = '';
            p2.style.transition = '';
        }

        function updatePlanetStyle(tile) {
            const planet = tile.el.querySelector('.planet');
            planet.style.background = PLANET_COLORS[tile.colorIdx];
            planet.style.boxShadow = `0 0 10px ${PLANET_COLORS[tile.colorIdx]}`;
            
            // Bomb classes
            planet.classList.remove('bomb-h', 'bomb-v', 'bomb-5');
            if (tile.bomb === 'h') planet.classList.add('bomb-h');
            if (tile.bomb === 'v') planet.classList.add('bomb-v');
            if (tile.bomb === '5') planet.classList.add('bomb-5');
        }

        async function checkAndClearMatches() {
            let hMatches = [];
            let vMatches = [];

            // Horizontal Detection
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE - 2; c++) {
                    let i = 1;
                    while (c + i < GRID_SIZE && grid[r][c + i].colorIdx === grid[r][c].colorIdx) i++;
                    if (i >= 3) {
                        const match = [];
                        for(let j=0; j<i; j++) match.push(grid[r][c+j]);
                        hMatches.push({tiles: match, len: i});
                        c += i - 1;
                    }
                }
            }

            // Vertical Detection
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE - 2; r++) {
                    let i = 1;
                    while (r + i < GRID_SIZE && grid[r + i][c].colorIdx === grid[r][c].colorIdx) i++;
                    if (i >= 3) {
                        const match = [];
                        for(let j=0; j<i; j++) match.push(grid[r+j][c]);
                        vMatches.push({tiles: match, len: i});
                        r += i - 1;
                    }
                }
            }

            const allMatchedTiles = new Set();
            hMatches.forEach(m => m.tiles.forEach(t => allMatchedTiles.add(t)));
            vMatches.forEach(m => m.tiles.forEach(t => allMatchedTiles.add(t)));

            if (allMatchedTiles.size > 0) {
                comboCount++;
                showComboText(comboCount);

                // Determine if a bomb should be created
                let bombType = null;
                let bombPos = lastMovedTile;

                // Priority: 5-match (Big Bomb) > 4-match (H/V Bomb)
                const isCombined = hMatches.some(hm => vMatches.some(vm => vm.tiles.some(vt => hm.tiles.includes(vt))));
                
                if (isCombined || hMatches.some(m => m.len >= 5) || vMatches.some(m => m.len >= 5)) {
                    bombType = '5';
                } else if (hMatches.some(m => m.len === 4)) {
                    bombType = 'h';
                } else if (vMatches.some(m => m.len === 4)) {
                    bombType = 'v';
                }

                // If no lastMovedTile (cascading match), use the first tile of the first match
                if (!bombPos && bombType) {
                    bombPos = [...allMatchedTiles][0];
                }

                // Score
                score += allMatchedTiles.size * 10;
                scoreEl.innerText = score;

                // Animate and Clear
                allMatchedTiles.forEach(m => {
                    if (bombType && m === bombPos) {
                        // Don't pop the tile where bomb will be
                    } else {
                        m.el.querySelector('.planet').classList.add('pop-anim');
                    }
                });
                
                await new Promise(resolve => setTimeout(resolve, 300));

                if (bombType && bombPos) {
                    bombPos.bomb = bombType;
                    updatePlanetStyle(bombPos);
                }

                lastMovedTile = null;
                await refillGrid();
                await checkAndClearMatches(); 
                return true;
            }
            return false;
        }

        async function refillGrid() {
            const config = DIFFICULTIES[currentDifficulty];
            for (let c = 0; c < GRID_SIZE; c++) {
                let emptySpots = 0;
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    const tile = grid[r][c];
                    const planetEl = tile.el.querySelector('.planet');
                    if (planetEl.classList.contains('pop-anim')) {
                        emptySpots++;
                        tile.bomb = null; 
                    } else if (emptySpots > 0) {
                        const targetR = r + emptySpots;
                        const targetTile = grid[targetR][c];
                        targetTile.colorIdx = tile.colorIdx;
                        targetTile.bomb = tile.bomb;
                        
                        const targetPlanet = targetTile.el.querySelector('.planet');
                        targetPlanet.classList.remove('pop-anim');
                        updatePlanetStyle(targetTile);
                        
                        targetPlanet.style.transition = 'none';
                        targetPlanet.style.transform = `translateY(${-emptySpots * 100}%)`;
                        targetPlanet.offsetHeight;
                        targetPlanet.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        targetPlanet.style.transform = 'translateY(0)';
                        
                        planetEl.classList.add('pop-anim');
                        tile.bomb = null;
                    }
                }
                for (let r = 0; r < emptySpots; r++) {
                    const tile = grid[r][c];
                    tile.colorIdx = Math.floor(Math.random() * config.colors);
                    tile.bomb = null;
                    const newPlanet = tile.el.querySelector('.planet');
                    newPlanet.classList.remove('pop-anim');
                    updatePlanetStyle(tile);
                    
                    newPlanet.style.transition = 'none';
                    newPlanet.style.transform = `translateY(${-emptySpots * 100}%)`;
                    newPlanet.offsetHeight;
                    newPlanet.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    newPlanet.style.transform = 'translateY(0)';
                }
            }
            return new Promise(resolve => setTimeout(resolve, 450));
        }

        function startGame() {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const config = DIFFICULTIES[currentDifficulty];
            score = 0;
            scoreEl.innerText = '0';
            timeLeft = config.time;
            gameActive = true;
            initGrid();
            updateBestScoreDisplay();
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft -= 0.1;
                const percentage = (timeLeft / config.time) * 100;
                timerFill.style.width = percentage + '%';
                if (timeLeft <= 0) {
                    gameOver();
                }
            }, 100);
        }

        function gameOver() {
            gameActive = false;
            clearInterval(timerInterval);
            finalScoreEl.innerText = score;
            const bestKey = `match_best_${currentDifficulty}`;
            const best = parseInt(localStorage.getItem(bestKey) || 0);
            if (score > best) {
                localStorage.setItem(bestKey, score);
                bestScoreEl.innerText = score;
            }
            document.getElementById('game-over-screen').classList.add('active');
        }

        updateBestScoreDisplay();
    </script>
</body>
</html>

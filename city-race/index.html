<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>City Race - Coin Collector</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@800&family=Space+Grotesk:wght@700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-purple: #bc13fe;
            --neon-gold: #ffd700;
            --bg-dark: #0a0a12;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-dark);
            overflow: hidden;
            font-family: 'Plus Jakarta Sans', sans-serif;
            color: white;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--neon-blue);
            letter-spacing: 0.1em;
        }

        .stat-value {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 24px;
            font-weight: 700;
        }

        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--neon-blue);
            border-radius: 15px;
            overflow: hidden;
            z-index: 10;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        .btn {
            background: var(--neon-purple);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 800;
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.2s, background 0.2s;
            box-shadow: 0 0 15px rgba(188, 19, 254, 0.3);
        }

        .btn:active {
            transform: scale(0.95);
        }

        #shop-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .shop-content {
            background: var(--bg-dark);
            border: 2px solid var(--neon-purple);
            border-radius: 25px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }

        .color-option {
            height: 60px;
            border-radius: 12px;
            cursor: pointer;
            border: 3px solid transparent;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            font-weight: bold;
        }

        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 15px white;
        }

        #joystick-container {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: none;
            touch-action: none;
            z-index: 50;
        }

        #joystick-knob {
            position: absolute;
            width: 60px;
            height: 60px;
            background: var(--neon-blue);
            border-radius: 50%;
            top: 30px;
            left: 30px;
            pointer-events: none;
            box-shadow: 0 0 15px var(--neon-blue);
        }

        @media (pointer: coarse) {
            #joystick-container {
                display: block;
            }
        }

        .back-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            text-decoration: none;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
            font-family: sans-serif;
            font-size: 14px;
            transition: background 0.3s;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .back-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }
    </style>
</head>

<body>
    <a href="../" class="back-btn">‚Üê Arcade</a>
    <div id="ui">
        <div class="stat-box">
            <div>
                <div class="stat-label">Coins</div>
                <div id="coin-val" class="stat-value">0</div>
            </div>
            <button class="btn" style="background: var(--neon-blue); color: black;" onclick="openShop()">SHOP</button>
        </div>
        <div style="font-size: 12px; color: #888; margin-top: 10px;">WASD or Arrows to drive</div>
    </div>

    <div id="minimap-container">
        <canvas id="minimap-canvas"></canvas>
    </div>

    <div id="joystick-container">
        <div id="joystick-knob"></div>
    </div>

    <div id="shop-modal">
        <div class="shop-content">
            <h2 style="font-size: 32px; margin-bottom: 10px;">GARAGE</h2>
            <p style="color: #888;">Select a new paint job for your vessel.</p>
            <div class="color-grid" id="color-list"></div>
            <button class="btn" onclick="closeShop()">CLOSE</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const mCanvas = document.getElementById('minimap-canvas');
        const mCtx = mCanvas.getContext('2d');
        const coinValEl = document.getElementById('coin-val');
        const shopModal = document.getElementById('shop-modal');
        const colorListEl = document.getElementById('color-list');

        // Constants
        const WORLD_SIZE = 4000;
        const BLOCK_SIZE = 500;
        const ROAD_WIDTH = 180;
        const COIN_RADIUS = 15;

        // Player State
        const car = {
            x: WORLD_SIZE / 2,
            y: WORLD_SIZE / 2,
            angle: 0,
            speed: 0,
            maxSpeed: 5.5,
            accel: 0.12,
            brake: 0.25,
            friction: 0.992, // Increased inertia
            steerAngle: 0,
            maxSteer: 0.45,
            steerSpeed: 0.08,
            width: 44,
            height: 24,
            wheelBase: 32,
            wheelWidth: 10,
            wheelHeight: 6,
            color: '#e74c3c',
            coins: parseInt(localStorage.getItem('city_coins') || '0')
        };

        const colors = [
            { name: 'Red', hex: '#e74c3c', cost: 0 },
            { name: 'Blue', hex: '#3498db', cost: 10 },
            { name: 'Green', hex: '#2ecc71', cost: 20 },
            { name: 'Gold', hex: '#f1c40f', cost: 50 },
            { name: 'Neon', hex: '#bc13fe', cost: 100 },
            { name: 'Ice', hex: '#00f3ff', cost: 150 }
        ];

        let coin = { x: 0, y: 0 };
        let buildings = [];
        let keys = {};
        let joystick = { x: 0, y: 0, active: false };
        let lastFrameTime = 0;
        const fpsInterval = 1000 / 60;

        function init() {
            // Generate City Grid
            for (let x = 0; x < WORLD_SIZE; x += BLOCK_SIZE) {
                for (let y = 0; y < WORLD_SIZE; y += BLOCK_SIZE) {
                    buildings.push({
                        x: x + ROAD_WIDTH / 2 + 20,
                        y: y + ROAD_WIDTH / 2 + 20,
                        w: BLOCK_SIZE - ROAD_WIDTH - 40,
                        h: BLOCK_SIZE - ROAD_WIDTH - 40,
                        color: `hsl(240, 20%, ${10 + Math.random() * 10}%)`
                    });
                }
            }
            spawnCoin();
            updateUI();

            const savedColor = localStorage.getItem('city_color');
            if (savedColor) car.color = savedColor;
        }

        function spawnCoin() {
            const isHorizontal = Math.random() > 0.5;
            if (isHorizontal) {
                const row = Math.floor(Math.random() * (WORLD_SIZE / BLOCK_SIZE));
                coin.x = Math.random() * WORLD_SIZE;
                coin.y = row * BLOCK_SIZE;
            } else {
                const col = Math.floor(Math.random() * (WORLD_SIZE / BLOCK_SIZE));
                coin.x = col * BLOCK_SIZE;
                coin.y = Math.random() * WORLD_SIZE;
            }
        }

        function updateUI() {
            coinValEl.innerText = car.coins;
            localStorage.setItem('city_coins', car.coins);
        }

        function openShop() {
            shopModal.style.display = 'flex';
            renderShop();
        }

        function closeShop() { shopModal.style.display = 'none'; }

        function renderShop() {
            colorListEl.innerHTML = '';
            colors.forEach(c => {
                const opt = document.createElement('div');
                opt.className = `color-option ${car.color === c.hex ? 'selected' : ''}`;
                opt.style.background = c.hex;

                const owned = localStorage.getItem(`city_owned_${c.name}`) || c.cost === 0;
                opt.innerHTML = `
                    <div style="color:black; background: white; padding: 2px 5px; border-radius: 4px;">
                        ${owned ? 'OWNED' : c.cost + 'üí∞'}
                    </div>
                `;

                opt.onclick = () => {
                    if (owned) {
                        car.color = c.hex;
                        localStorage.setItem('city_color', c.hex);
                        renderShop();
                    } else if (car.coins >= c.cost) {
                        car.coins -= c.cost;
                        localStorage.setItem(`city_owned_${c.name}`, 'true');
                        car.color = c.hex;
                        localStorage.setItem('city_color', c.hex);
                        updateUI();
                        renderShop();
                    }
                };
                colorListEl.appendChild(opt);
            });
        }

        function update(dt) {
            const speedFactor = Math.abs(car.speed) / car.maxSpeed;
            const currentMaxSteer = car.maxSteer * (1.6 - speedFactor * 0.8);

            let targetSteer = 0;
            if (keys['KeyA'] || keys['ArrowLeft'] || joystick.x < -0.2) targetSteer = -currentMaxSteer;
            if (keys['KeyD'] || keys['ArrowRight'] || joystick.x > 0.2) targetSteer = currentMaxSteer;
            car.steerAngle += (targetSteer - car.steerAngle) * car.steerSpeed * dt;

            let forward = keys['KeyW'] || keys['ArrowUp'] || joystick.y < -0.2;
            let backward = keys['KeyS'] || keys['ArrowDown'] || joystick.y > 0.2;

            if (forward) car.speed += car.accel * dt;
            else if (backward) car.speed -= car.brake * dt;
            else {
                car.speed *= Math.pow(car.friction, dt);
                if (Math.abs(car.speed) < 0.05) car.speed = 0;
            }

            car.speed = Math.max(-car.maxSpeed / 2, Math.min(car.maxSpeed, car.speed));

            const moveStep = car.speed * dt;
            const frontWheel = {
                x: car.x + Math.cos(car.angle) * car.wheelBase / 2 + Math.cos(car.angle + car.steerAngle) * moveStep,
                y: car.y + Math.sin(car.angle) * car.wheelBase / 2 + Math.sin(car.angle + car.steerAngle) * moveStep
            };
            const backWheel = {
                x: car.x - Math.cos(car.angle) * car.wheelBase / 2 + Math.cos(car.angle) * moveStep,
                y: car.y - Math.sin(car.angle) * car.wheelBase / 2 + Math.sin(car.angle) * moveStep
            };

            const nextX = (frontWheel.x + backWheel.x) / 2;
            const nextY = (frontWheel.y + backWheel.y) / 2;

            let collided = false;
            for (const b of buildings) {
                if (nextX > b.x - 10 && nextX < b.x + b.w + 10 && nextY > b.y - 10 && nextY < b.y + b.h + 10) {
                    collided = true;
                    break;
                }
            }

            if (!collided) {
                car.x = nextX;
                car.y = nextY;
                car.angle = Math.atan2(frontWheel.y - backWheel.y, frontWheel.x - backWheel.x);
            } else {
                car.speed *= -0.6;
            }

            car.x = Math.max(0, Math.min(WORLD_SIZE, car.x));
            car.y = Math.max(0, Math.min(WORLD_SIZE, car.y));

            const distToCoin = Math.hypot(car.x - coin.x, car.y - coin.y);
            if (distToCoin < 40) {
                car.coins++;
                updateUI();
                spawnCoin();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.translate(-car.x, -car.y);

            ctx.fillStyle = '#050508';
            ctx.fillRect(-1000, -1000, WORLD_SIZE + 2000, WORLD_SIZE + 2000);

            ctx.fillStyle = '#1a1a2e';
            for (let i = 0; i <= WORLD_SIZE; i += BLOCK_SIZE) {
                ctx.fillRect(0, i - ROAD_WIDTH / 2, WORLD_SIZE, ROAD_WIDTH);
                ctx.fillRect(i - ROAD_WIDTH / 2, 0, ROAD_WIDTH, WORLD_SIZE);
            }

            // Draw Road Lines (Skipping intersections to avoid crosswalk overlap)
            ctx.lineWidth = 2;
            for (let i = 0; i <= WORLD_SIZE; i += BLOCK_SIZE) {
                // Horizontal lines
                for (let x = 0; x < WORLD_SIZE; x += BLOCK_SIZE) {
                    const startX = x + ROAD_WIDTH / 2 + 60;
                    const endX = x + BLOCK_SIZE - ROAD_WIDTH / 2 - 60;
                    if (startX >= endX) continue;

                    ctx.setLineDash([]);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(startX, i - ROAD_WIDTH / 2 + 5); ctx.lineTo(endX, i - ROAD_WIDTH / 2 + 5);
                    ctx.moveTo(startX, i + ROAD_WIDTH / 2 - 5); ctx.lineTo(endX, i + ROAD_WIDTH / 2 - 5);
                    ctx.stroke();

                    // Lanes
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.setLineDash([20, 30]);
                    ctx.beginPath();
                    ctx.moveTo(startX, i - ROAD_WIDTH / 4); ctx.lineTo(endX, i - ROAD_WIDTH / 4);
                    ctx.moveTo(startX, i + ROAD_WIDTH / 4); ctx.lineTo(endX, i + ROAD_WIDTH / 4);
                    ctx.stroke();

                    // Center yellow lines
                    ctx.strokeStyle = '#ffd700';
                    ctx.setLineDash([]); // Change to solid
                    ctx.beginPath();
                    ctx.moveTo(startX, i - 2); ctx.lineTo(endX, i - 2);
                    ctx.moveTo(startX, i + 2); ctx.lineTo(endX, i + 2);
                    ctx.stroke();
                }

                // Vertical lines
                for (let y = 0; y < WORLD_SIZE; y += BLOCK_SIZE) {
                    const startY = y + ROAD_WIDTH / 2 + 60;
                    const endY = y + BLOCK_SIZE - ROAD_WIDTH / 2 - 60;
                    if (startY >= endY) continue;

                    ctx.setLineDash([]);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(i - ROAD_WIDTH / 2 + 5, startY); ctx.lineTo(i - ROAD_WIDTH / 2 + 5, endY);
                    ctx.moveTo(i + ROAD_WIDTH / 2 - 5, startY); ctx.lineTo(i + ROAD_WIDTH / 2 - 5, endY);
                    ctx.stroke();

                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.setLineDash([20, 30]);
                    ctx.beginPath();
                    ctx.moveTo(i - ROAD_WIDTH / 4, startY); ctx.lineTo(i - ROAD_WIDTH / 4, endY);
                    ctx.moveTo(i + ROAD_WIDTH / 4, startY); ctx.lineTo(i + ROAD_WIDTH / 4, endY);
                    ctx.stroke();

                    ctx.strokeStyle = '#ffd700';
                    ctx.setLineDash([]); // Change to solid
                    ctx.beginPath();
                    ctx.moveTo(i - 2, startY); ctx.lineTo(i - 2, endY);
                    ctx.moveTo(i + 2, startY); ctx.lineTo(i + 2, endY);
                    ctx.stroke();
                }
            }

            ctx.setLineDash([]);
            for (let x = 0; x <= WORLD_SIZE; x += BLOCK_SIZE) {
                for (let y = 0; y <= WORLD_SIZE; y += BLOCK_SIZE) {
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(x - ROAD_WIDTH / 2, y - ROAD_WIDTH / 2, ROAD_WIDTH, ROAD_WIDTH);
                    drawCrosswalk(x, y);
                }
            }

            buildings.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.fillRect(b.x, b.y, b.w, b.h);
                ctx.fillStyle = 'rgba(0, 243, 255, 0.1)';
                for (let wx = b.x + 20; wx < b.x + b.w - 20; wx += 40) {
                    for (let wy = b.y + 20; wy < b.y + b.h - 20; wy += 40) {
                        ctx.fillRect(wx, wy, 15, 15);
                    }
                }
            });

            ctx.fillStyle = varToHex('--neon-gold');
            ctx.shadowBlur = 20;
            ctx.shadowColor = varToHex('--neon-gold');
            ctx.beginPath();
            ctx.arc(coin.x, coin.y, COIN_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw Car with Wheels
            ctx.save();
            ctx.translate(car.x, car.y);
            ctx.rotate(car.angle);

            // 1. Rear Wheels (Fixed)
            ctx.fillStyle = '#111';
            ctx.fillRect(-car.wheelBase / 2 - car.wheelWidth / 2, -car.height / 2 - 2, car.wheelWidth, car.wheelHeight);
            ctx.fillRect(-car.wheelBase / 2 - car.wheelWidth / 2, car.height / 2 - car.wheelHeight + 2, car.wheelWidth, car.wheelHeight);

            // 2. Front Wheels (Steering)
            ctx.save();
            ctx.translate(car.wheelBase / 2, -car.height / 2 - 2);
            ctx.rotate(car.steerAngle);
            ctx.fillRect(-car.wheelWidth / 2, -car.wheelHeight / 2, car.wheelWidth, car.wheelHeight);
            ctx.restore();

            ctx.save();
            ctx.translate(car.wheelBase / 2, car.height / 2 + 2);
            ctx.rotate(car.steerAngle);
            ctx.fillRect(-car.wheelWidth / 2, -car.wheelHeight / 2, car.wheelWidth, car.wheelHeight);
            ctx.restore();

            // 3. Car Body
            ctx.fillStyle = car.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = car.color;
            ctx.fillRect(-car.width / 2, -car.height / 2, car.width, car.height);
            ctx.shadowBlur = 0;

            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(-10, -car.height / 2 + 4, 25, car.height - 8);

            ctx.fillStyle = '#fff';
            ctx.fillRect(car.width / 2 - 6, -car.height / 2 + 3, 6, 6);
            ctx.fillRect(car.width / 2 - 6, car.height / 2 - 9, 6, 6);

            ctx.restore();
            ctx.restore();

            drawMinimap();
        }

        function drawCrosswalk(x, y) {
            const cwW = 20; // Crosswalk band width
            const stripeW = 6; // Stripe width
            const stripeGap = 12;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';

            // Top
            for (let i = -ROAD_WIDTH / 2 + 10; i < ROAD_WIDTH / 2 - 10; i += stripeGap) {
                // Row 1
                ctx.fillRect(x + i, y - ROAD_WIDTH / 2 - cwW - 5, stripeW, cwW);
                // Row 2 (offset)
                ctx.fillRect(x + i + stripeW, y - ROAD_WIDTH / 2 - 2 * cwW - 5, stripeW, cwW);
            }
            // Bottom
            for (let i = -ROAD_WIDTH / 2 + 10; i < ROAD_WIDTH / 2 - 10; i += stripeGap) {
                // Row 1
                ctx.fillRect(x + i, y + ROAD_WIDTH / 2 + 5, stripeW, cwW);
                // Row 2 (offset)
                ctx.fillRect(x + i + stripeW, y + ROAD_WIDTH / 2 + cwW + 5, stripeW, cwW);
            }
            // Left
            for (let i = -ROAD_WIDTH / 2 + 10; i < ROAD_WIDTH / 2 - 10; i += stripeGap) {
                // Row 1
                ctx.fillRect(x - ROAD_WIDTH / 2 - cwW - 5, y + i, cwW, stripeW);
                // Row 2 (offset)
                ctx.fillRect(x - ROAD_WIDTH / 2 - 2 * cwW - 5, y + i + stripeW, cwW, stripeW);
            }
            // Right
            for (let i = -ROAD_WIDTH / 2 + 10; i < ROAD_WIDTH / 2 - 10; i += stripeGap) {
                // Row 1
                ctx.fillRect(x + ROAD_WIDTH / 2 + 5, y + i, cwW, stripeW);
                // Row 2 (offset)
                ctx.fillRect(x + ROAD_WIDTH / 2 + cwW + 5, y + i + stripeW, cwW, stripeW);
            }
        }

        function drawMinimap() {
            mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);
            const scale = mCanvas.width / WORLD_SIZE;

            // Buildings
            mCtx.fillStyle = '#222';
            buildings.forEach(b => {
                mCtx.fillRect(b.x * scale, b.y * scale, b.w * scale, b.h * scale);
            });

            // Coin
            mCtx.fillStyle = varToHex('--neon-gold');
            mCtx.beginPath();
            mCtx.arc(coin.x * scale, coin.y * scale, 4, 0, Math.PI * 2);
            mCtx.fill();

            // Player
            mCtx.fillStyle = car.color;
            mCtx.beginPath();
            mCtx.arc(car.x * scale, car.y * scale, 5, 0, Math.PI * 2);
            mCtx.fill();
            // Direction line
            mCtx.strokeStyle = 'white';
            mCtx.beginPath();
            mCtx.moveTo(car.x * scale, car.y * scale);
            mCtx.lineTo((car.x + Math.cos(car.angle) * 300) * scale, (car.y + Math.sin(car.angle) * 300) * scale);
            mCtx.stroke();
        }

        function varToHex(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }

        // Controls
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        // Joystick
        const jContainer = document.getElementById('joystick-container');
        const jKnob = document.getElementById('joystick-knob');
        jContainer.addEventListener('touchstart', e => { joystick.active = true; });
        window.addEventListener('touchmove', e => {
            if (!joystick.active) return;
            const rect = jContainer.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const tx = e.touches[0].clientX - cx;
            const ty = e.touches[0].clientY - cy;
            const dist = Math.hypot(tx, ty);
            const max = rect.width / 2;
            const nx = tx / (dist || 1);
            const ny = ty / (dist || 1);
            const limitedDist = Math.min(dist, max);

            joystick.x = (nx * limitedDist) / max;
            joystick.y = (ny * limitedDist) / max;

            jKnob.style.transform = `translate(calc(-50% + ${nx * limitedDist}px), calc(-50% + ${ny * limitedDist}px))`;
        });
        window.addEventListener('touchend', () => {
            joystick.active = false;
            joystick.x = 0; joystick.y = 0;
            jKnob.style.transform = 'translate(-50%, -50%)';
        });

        function loop(timestamp) {
            requestAnimationFrame(loop);
            
            if (!lastFrameTime) lastFrameTime = timestamp;
            const elapsed = timestamp - lastFrameTime;
            lastFrameTime = timestamp;

            // Calculate delta time factor (1.0 = 60fps)
            // Limit delta to avoid huge jumps if window loses focus
            const dt = Math.min(elapsed / (1000 / 60), 3);

            if (shopModal.style.display !== 'flex') update(dt);
            draw();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            mCanvas.width = 200;
            mCanvas.height = 200;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        init();
        requestAnimationFrame(loop);
    </script>
</body>

</html>